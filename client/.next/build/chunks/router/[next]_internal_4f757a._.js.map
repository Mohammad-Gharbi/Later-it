{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/headers.ts"],"sourcesContent":["/**\n * Converts an array of raw header entries to a map of header names to values.\n */\nexport function headersFromEntries(\n  entries: Array<[string, string]>\n): Record<string, string | string[]> {\n  const headers: Record<string, string | string[]> = Object.create(null)\n  for (const [key, value] of entries) {\n    if (key in headers) {\n      const prevValue = headers[key]\n      if (typeof prevValue === 'string') {\n        headers[key] = [prevValue, value]\n      } else {\n        prevValue.push(value)\n      }\n    } else {\n      headers[key] = value\n    }\n  }\n  return headers\n}\n\n/**\n * Transforms an array of elements into an array of pairs of elements.\n *\n * ## Example\n *\n * ```ts\n * toPairs([\"a\", \"b\", \"c\", \"d\"]) // => [[\"a\", \"b\"], [\"c\", \"d\"]]\n * ```\n */\nexport function toPairs<T>(arr: T[]): Array<[T, T]> {\n  if (arr.length % 2 !== 0) {\n    throw new Error('toPairs: expected an even number of elements')\n  }\n\n  const pairs: Array<[T, T]> = []\n  for (let i = 0; i < arr.length; i += 2) {\n    pairs.push([arr[i], arr[i + 1]])\n  }\n\n  return pairs\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,mBACd,OAAgC,EACG;IACnC,MAAM,UAA6C,OAAO,MAAM,CAAC,IAAI;IACrE,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAS;QAClC,IAAI,OAAO,SAAS;YAClB,MAAM,YAAY,OAAO,CAAC,IAAI;YAC9B,IAAI,OAAO,cAAc,UAAU;gBACjC,OAAO,CAAC,IAAI,GAAG;oBAAC;oBAAW;iBAAM;YACnC,OAAO;gBACL,UAAU,IAAI,CAAC;YACjB,CAAC;QACH,OAAO;YACL,OAAO,CAAC,IAAI,GAAG;QACjB,CAAC;IACH;IACA,OAAO;AACT;AAWO,SAAS,QAAW,GAAQ,EAAiB;IAClD,IAAI,IAAI,MAAM,GAAG,MAAM,GAAG;QACxB,MAAM,IAAI,MAAM,gDAA+C;IACjE,CAAC;IAED,MAAM,QAAuB,EAAE;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;QACtC,MAAM,IAAI,CAAC;YAAC,GAAG,CAAC,EAAE;YAAE,GAAG,CAAC,IAAI,EAAE;SAAC;IACjC;IAEA,OAAO;AACT"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/server.ts"],"sourcesContent":["import type { ClientRequest, IncomingMessage, Server } from 'node:http'\nimport type { AddressInfo } from 'node:net'\nimport http, { ServerResponse } from 'node:http'\nimport { headersFromEntries } from './headers'\n\n/**\n * Creates a server that listens a random port.\n */\nexport function createServer(): Promise<Server> {\n  return new Promise((resolve) => {\n    const server = http.createServer()\n    server.listen(0, () => {\n      resolve(server)\n    })\n  })\n}\n\n/**\n * Creates a request to a server, and returns the (req, res) pairs from both\n * the client's and server's perspective.\n */\nexport function makeRequest(\n  server: Server,\n  method: string,\n  path: string,\n  rawQuery?: string,\n  rawHeaders?: [string, string][]\n): Promise<{\n  clientRequest: ClientRequest\n  clientResponsePromise: Promise<IncomingMessage>\n  serverRequest: IncomingMessage\n  serverResponse: ServerResponse<IncomingMessage>\n}> {\n  return new Promise((resolve, reject) => {\n    let clientRequest: ClientRequest | null = null\n    let clientResponseResolve: (value: IncomingMessage) => void\n    let clientResponseReject: (error: Error) => void\n    const clientResponsePromise = new Promise<IncomingMessage>(\n      (resolve, reject) => {\n        clientResponseResolve = resolve\n        clientResponseReject = reject\n      }\n    )\n    let serverRequest: IncomingMessage | null = null\n    let serverResponse: ServerResponse<IncomingMessage> | null = null\n\n    const maybeResolve = () => {\n      if (\n        clientRequest != null &&\n        serverRequest != null &&\n        serverResponse != null\n      ) {\n        cleanup()\n        resolve({\n          clientRequest,\n          clientResponsePromise,\n          serverRequest,\n          serverResponse,\n        })\n      }\n    }\n\n    const cleanup = () => {\n      server.removeListener('error', errorListener)\n      server.removeListener('request', requestListener)\n    }\n\n    const errorListener = (err: Error) => {\n      cleanup()\n      reject(err)\n    }\n\n    const requestListener = (\n      req: IncomingMessage,\n      res: ServerResponse<IncomingMessage>\n    ) => {\n      serverRequest = req\n      serverResponse = res\n      maybeResolve()\n    }\n\n    const cleanupClientResponse = () => {\n      if (clientRequest != null) {\n        clientRequest.removeListener('response', responseListener)\n        clientRequest.removeListener('error', clientResponseErrorListener)\n      }\n    }\n\n    const clientResponseErrorListener = (err: Error) => {\n      cleanupClientResponse()\n      clientResponseReject(err)\n    }\n\n    const responseListener = (res: IncomingMessage) => {\n      cleanupClientResponse()\n      clientResponseResolve(res)\n    }\n\n    server.once('request', requestListener)\n    server.once('error', errorListener)\n\n    const address = server.address() as AddressInfo\n\n    clientRequest = http.request({\n      host: 'localhost',\n      port: address.port,\n      method,\n      path:\n        rawQuery != null && rawQuery.length > 0 ? `${path}?${rawQuery}` : path,\n      headers: rawHeaders != null ? headersFromEntries(rawHeaders) : undefined,\n    })\n\n    // Otherwise Node.js waits for the first chunk of data to be written before sending the request.\n    clientRequest.flushHeaders()\n\n    clientRequest.once('response', responseListener)\n    clientRequest.once('error', clientResponseErrorListener)\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;AAQO,SAAS,eAAgC;IAC9C,OAAO,IAAI,QAAQ,CAAC,UAAY;QAC9B,MAAM,SAAS,iDAAK,YAAY;QAChC,OAAO,MAAM,CAAC,GAAG,IAAM;YACrB,QAAQ;QACV;IACF;AACF;AAMO,SAAS,YACd,MAAc,EACd,MAAc,EACd,IAAY,EACZ,QAAiB,EACjB,UAA+B,EAM9B;IACD,OAAO,IAAI,QAAQ,CAAC,SAAS,SAAW;QACtC,IAAI,gBAAsC,IAAI;QAC9C,IAAI;QACJ,IAAI;QACJ,MAAM,wBAAwB,IAAI,QAChC,CAAC,SAAS,SAAW;YACnB,wBAAwB;YACxB,uBAAuB;QACzB;QAEF,IAAI,gBAAwC,IAAI;QAChD,IAAI,iBAAyD,IAAI;QAEjE,MAAM,eAAe,IAAM;YACzB,IACE,iBAAiB,IAAI,IACrB,iBAAiB,IAAI,IACrB,kBAAkB,IAAI,EACtB;gBACA;gBACA,QAAQ;oBACN;oBACA;oBACA;oBACA;gBACF;YACF,CAAC;QACH;QAEA,MAAM,UAAU,IAAM;YACpB,OAAO,cAAc,CAAC,SAAS;YAC/B,OAAO,cAAc,CAAC,WAAW;QACnC;QAEA,MAAM,gBAAgB,CAAC,MAAe;YACpC;YACA,OAAO;QACT;QAEA,MAAM,kBAAkB,CACtB,KACA,MACG;YACH,gBAAgB;YAChB,iBAAiB;YACjB;QACF;QAEA,MAAM,wBAAwB,IAAM;YAClC,IAAI,iBAAiB,IAAI,EAAE;gBACzB,cAAc,cAAc,CAAC,YAAY;gBACzC,cAAc,cAAc,CAAC,SAAS;YACxC,CAAC;QACH;QAEA,MAAM,8BAA8B,CAAC,MAAe;YAClD;YACA,qBAAqB;QACvB;QAEA,MAAM,mBAAmB,CAAC,MAAyB;YACjD;YACA,sBAAsB;QACxB;QAEA,OAAO,IAAI,CAAC,WAAW;QACvB,OAAO,IAAI,CAAC,SAAS;QAErB,MAAM,UAAU,OAAO,OAAO;QAE9B,gBAAgB,iDAAK,OAAO,CAAC;YAC3B,MAAM;YACN,MAAM,QAAQ,IAAI;YAClB;YACA,MACE,YAAY,IAAI,IAAI,SAAS,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,GAAG,IAAI;YACxE,SAAS,cAAc,IAAI,GAAG,mHAAmB,cAAc,SAAS;QAC1E;QAGA,cAAc,YAAY;QAE1B,cAAc,IAAI,CAAC,YAAY;QAC/B,cAAc,IAAI,CAAC,SAAS;IAC9B;AACF"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}