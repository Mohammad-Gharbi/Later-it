{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/entry/router.ts"],"sourcesContent":["import type { Ipc, StructuredError } from '@vercel/turbopack-node/ipc/index'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { Buffer } from 'node:buffer'\nimport { createServer, makeRequest } from '../internal/server'\nimport { toPairs } from '../internal/headers'\nimport {\n  makeResolver,\n  RouteResult,\n  ServerAddress,\n} from 'next/dist/server/lib/route-resolver'\nimport loadConfig from 'next/dist/server/config'\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/dist/shared/lib/constants'\n\nimport 'next/dist/server/node-polyfill-fetch.js'\n\nimport middlewareChunkGroup from 'MIDDLEWARE_CHUNK_GROUP'\nimport middlewareConfig from 'MIDDLEWARE_CONFIG'\n\ntype RouterRequest = {\n  method: string\n  pathname: string\n  rawHeaders: [string, string][]\n  rawQuery: string\n  body: number[][]\n}\n\ntype IpcOutgoingMessage = {\n  type: 'value'\n  data: string | Buffer\n}\n\ntype MessageData =\n  | { type: 'middleware-headers'; data: MiddlewareHeadersResponse }\n  | { type: 'middleware-body'; data: Uint8Array }\n  | {\n      type: 'rewrite'\n      data: RewriteResponse\n    }\n  | {\n      type: 'error'\n      error: StructuredError\n    }\n  | { type: 'none' }\n\ntype RewriteResponse = {\n  url: string\n  headers: [string, string][]\n}\n\ntype MiddlewareHeadersResponse = {\n  statusCode: number\n  headers: [string, string][]\n}\n\nlet resolveRouteMemo: Promise<\n  (req: IncomingMessage, res: ServerResponse) => Promise<void>\n>\n\nasync function getResolveRoute(\n  dir: string,\n  serverAddr: Partial<ServerAddress>\n): ReturnType<\n  typeof import('next/dist/server/lib/route-resolver').makeResolver\n> {\n  const nextConfig = await loadConfig(\n    PHASE_DEVELOPMENT_SERVER,\n    process.cwd(),\n    undefined,\n    undefined,\n    true\n  )\n  const middlewareCfg = {\n    files: middlewareChunkGroup.filter((f) => /\\.[mc]?js$/.test(f)),\n    matcher: middlewareConfig.matcher,\n  }\n\n  return await makeResolver(dir, nextConfig, middlewareCfg, serverAddr)\n}\n\nexport default async function route(\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\n  routerRequest: RouterRequest,\n  dir: string,\n  serverAddr: Partial<ServerAddress>\n) {\n  const [resolveRoute, server] = await Promise.all([\n    (resolveRouteMemo ??= getResolveRoute(dir, serverAddr)),\n    createServer(),\n  ])\n\n  try {\n    const {\n      clientRequest,\n      clientResponsePromise,\n      serverRequest,\n      serverResponse,\n    } = await makeRequest(\n      server,\n      routerRequest.method,\n      routerRequest.pathname,\n      routerRequest.rawQuery,\n      routerRequest.rawHeaders\n    )\n\n    const body = Buffer.concat(\n      routerRequest.body.map((arr) => Buffer.from(arr))\n    )\n\n    // Send the clientRequest, so the server parses everything. We can then pass\n    // the serverRequest to Next.js to handle.\n    clientRequest.end(body)\n\n    // The route promise must not block us from starting the client response\n    // handling, so we cannot await it yet. By making the call, we allow\n    // Next.js to start writing to the response whenever it's ready.\n    const routePromise = resolveRoute(serverRequest, serverResponse)\n\n    // Now that the Next.js has started processing the route, the\n    // clientResponsePromise will resolve once they write data and then we can\n    // begin streaming.\n    // We again cannot block on the clientResponsePromise, because an error may\n    // occur in the routePromise while we're waiting.\n    const responsePromise = clientResponsePromise.then((c) =>\n      handleClientResponse(ipc, c)\n    )\n\n    // Now that both promises are in progress, we await both so that a\n    // rejection in either will end the routing.\n    const [response] = await Promise.all([responsePromise, routePromise])\n\n    server.close()\n    return response\n  } catch (e) {\n    // Server doesn't need to be closed, because the sendError will terminate\n    // the process.\n    ipc.sendError(e as Error)\n  }\n}\n\nasync function handleClientResponse(\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\n  clientResponse: IncomingMessage\n): Promise<MessageData | void> {\n  if (clientResponse.headers['x-nextjs-route-result'] === '1') {\n    clientResponse.setEncoding('utf8')\n    // We're either a redirect or a rewrite\n    let buffer = ''\n    for await (const chunk of clientResponse) {\n      buffer += chunk\n    }\n\n    const data = JSON.parse(buffer) as RouteResult\n\n    switch (data.type) {\n      case 'none':\n        return {\n          type: 'none',\n        }\n      case 'error':\n        return {\n          type: 'error',\n          error: data.error,\n        }\n      case 'rewrite':\n        return {\n          type: 'rewrite',\n          data: {\n            url: data.url,\n            headers: Object.entries(data.headers)\n              .filter(([, val]) => val != null)\n              .map(([name, value]) => [name, value!.toString()]),\n          },\n        }\n      default:\n        // @ts-expect-error data.type is never\n        throw new Error(`unknown route result type: ${data.type}`)\n    }\n  }\n\n  const responseHeaders: MiddlewareHeadersResponse = {\n    statusCode: clientResponse.statusCode!,\n    headers: toPairs(clientResponse.rawHeaders),\n  }\n\n  await ipc.send({\n    type: 'value',\n    data: JSON.stringify({\n      type: 'middleware-headers',\n      data: responseHeaders,\n    }),\n  })\n\n  for await (const chunk of clientResponse) {\n    await ipc.send({\n      type: 'value',\n      data: JSON.stringify({\n        type: 'middleware-body',\n        data: (chunk as Buffer).toJSON().data,\n      }),\n    })\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsDA,IAAI;AAIJ,eAAe,gBACb,GAAW,EACX,UAAkC,EAGlC;IACA,MAAM,aAAa,MAAM,sKAEvB,QAAQ,GAAG,IACX,WACA,WACA,IAAI;IAEN,MAAM,gBAAgB;QACpB,OAAO,kGAAqB,MAAM,CAAC,CAAC,IAAM,aAAa,IAAI,CAAC;QAC5D,SAAS,yGAAiB,OAAO;IACnC;IAEA,OAAO,MAAM,4FAAa,KAAK,YAAY,eAAe;AAC5D;AAEe,eAAe,MAC5B,GAA2C,EAC3C,aAA4B,EAC5B,GAAW,EACX,UAAkC,EAClC;IACA,MAAM,CAAC,cAAc,OAAO,GAAG,MAAM,QAAQ,GAAG,CAAC;QAC9C,qBAAqB,gBAAgB,KAAK;QAC3C;KACD;IAED,IAAI;QACF,MAAM,EACJ,cAAa,EACb,sBAAqB,EACrB,cAAa,EACb,eAAc,EACf,GAAG,MAAM,2GACR,QACA,cAAc,MAAM,EACpB,cAAc,QAAQ,EACtB,cAAc,QAAQ,EACtB,cAAc,UAAU;QAG1B,MAAM,OAAO,kDAAO,MAAM,CACxB,cAAc,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,kDAAO,IAAI,CAAC;QAK9C,cAAc,GAAG,CAAC;QAKlB,MAAM,eAAe,aAAa,eAAe;QAOjD,MAAM,kBAAkB,sBAAsB,IAAI,CAAC,CAAC,IAClD,qBAAqB,KAAK;QAK5B,MAAM,CAAC,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;YAAC;YAAiB;SAAa;QAEpE,OAAO,KAAK;QACZ,OAAO;IACT,EAAE,OAAO,GAAG;QAGV,IAAI,SAAS,CAAC;IAChB;AACF;AAEA,eAAe,qBACb,GAA2C,EAC3C,cAA+B,EACF;IAC7B,IAAI,eAAe,OAAO,CAAC,wBAAwB,KAAK,KAAK;QAC3D,eAAe,WAAW,CAAC;QAE3B,IAAI,SAAS;QACb,WAAW,MAAM,SAAS,eAAgB;YACxC,UAAU;QACZ;QAEA,MAAM,OAAO,KAAK,KAAK,CAAC;QAExB,OAAQ,KAAK,IAAI;YACf,KAAK;gBACH,OAAO;oBACL,MAAM;gBACR;YACF,KAAK;gBACH,OAAO;oBACL,MAAM;oBACN,OAAO,KAAK,KAAK;gBACnB;YACF,KAAK;gBACH,OAAO;oBACL,MAAM;oBACN,MAAM;wBACJ,KAAK,KAAK,GAAG;wBACb,SAAS,OAAO,OAAO,CAAC,KAAK,OAAO,EACjC,MAAM,CAAC,CAAC,GAAG,IAAI,GAAK,OAAO,IAAI,EAC/B,GAAG,CAAC,CAAC,CAAC,MAAM,MAAM,GAAK;gCAAC;gCAAM,MAAO,QAAQ;6BAAG;oBACrD;gBACF;YACF;gBAEE,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,IAAI,CAAC,CAAC,EAAC;QAC9D;IACF,CAAC;IAED,MAAM,kBAA6C;QACjD,YAAY,eAAe,UAAU;QACrC,SAAS,wGAAQ,eAAe,UAAU;IAC5C;IAEA,MAAM,IAAI,IAAI,CAAC;QACb,MAAM;QACN,MAAM,KAAK,SAAS,CAAC;YACnB,MAAM;YACN,MAAM;QACR;IACF;IAEA,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,IAAI,IAAI,CAAC;YACb,MAAM;YACN,MAAM,KAAK,SAAS,CAAC;gBACnB,MAAM;gBACN,MAAM,AAAC,MAAiB,MAAM,GAAG,IAAI;YACvC;QACF;IACF;AACF"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}